# Detached Interactive Shell

## Launching an interactive shell

An **interactive** shell is a shell connected to your standard input. The easiest example is the shell you see when you open up a terminal. You can execute a command through your keyboard, get the instant result, browse your filesystem, and so on. You get the idea. Trivially, the opposite thing is a **non-interactive** shell. You can't (or _don't want to) do any of those things on your non-interactive shell because it's mainly used to execute a command given to the shell before the execution.

`bash` takes advantage of this definition to decide if a new `bash` instance should be interactive or non-interactive. That is, if the standard input of the new `bash` instance is your keyboard, it assumes it should be an interactive shell, otherwise a non-interactive shell. 

Why is it relevant to `tmox`? Because `tmox` will have to redirect the standard input to somewhere user-controllable (without `root`). A non-privileged user (i.e., non-`root`) cannot directly access or control any physical device such as a keyboard, so there is no way to redirect the standard input to something acting as a physical device (as far as I know). So our second best bet is to redirect it to a user-controllable file (say, the file belonging to the user), but it'll make our new `bash` instance **non-interactive** because the standard input is not a keyboard ("character device" in a technical term). So if you launch `bash` and redirect its input to a file, the resulting `bash` instance is not the same as the one you see in your terminal; different formatting from `ls`, complaints from any `ncurses` applications, and so on. Simply speaking, it's not compatible with some terminal applications.

But in this case, the solution is **very** simple. You just need the `-i` flag when you launch `bash`. It instructs your `bash` instance to be an interactive shell no matter what. Simple as that.

## Detaching a process from the launching script

The whole point of this project is creating a shell detached from your terminal (so that it can be attached as you please later at time). But it's not automatically achievable because of how Linux processes work. Basically in Linux, all processes are killed when their parent process is dead. What it means here is that your new `bash` instance will be killed second after you close your terminal (because the shell of your terminal is the parent process of your `bash` process). Notice that launching `bash` as a background process doesn't help because, even if the `bash` instance would run parallel to your terminal shell in that case, it doesn't change the fact that it still belongs to the terminal shell.

What we need here is to spawn a `bash` instance **independent on** the terminal shell. How can this be done? Let's just briefly look at how the soon-to-be-dead parent process purges its children. Before death, it sends a signal called *hang-up* (`SIGHUP`) to its decendants; the signal name is pretty self-explanatory - "Imma hang up," like hanging up a phone call. The decendants receive the signal and commit suicide. What we can do here is that, if we make the decendant defiant and ignore the hang-up signal, theortically it won't kill itself and outlive its parent. 

It's the basic idea, and there is a built-in tool for that; `nohup`. It's a POSIX requirement (c.f., POSIX is a standard OS interface for UNIX-like operating systems) so it can be found in any sane Linux distros. What it does is launch a specified command (i.e., the `<command>` in the `nohup <command>` command-line) and make it ignore the hang-up signal. There should be more techincal details that this simplistic explanation, but I just speculate that what it really does is not just ignoring the signal but intercepting the signal to *re-*parent that soon-to-be-orphan process to a higher ancestor process.

**But,** this is not the end of the story. I discovered that, for some reason, `nohup` *doesn't* work when it was called inside a regular script. Specifically, when I interrupted the script with Ctrl+C, the resulting `bash` instance (with `nohup`) was killed together. I'm not 100% sure it commmits suicide because it also receives Ctrl+C (`SIGINT`) or its parent is dead, but for unknown reasons, enabling job control in the script (`set -m`) solved the issue. It's probably because `nohup` without job control (i.e., without `set -m`) cannot `nohup`. (According to [this arcicle](https://unix.stackexchange.com/questions/196603/can-someone-explain-in-detail-what-set-m-does), job control is disabled by default if the script is non-interative. The script that spawns our `bash` instance will be non-interactive, so `set -m` is necessary.)
